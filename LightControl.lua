{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"local Title = \"DU-LightControl\" --export: used only with Master_Unit\nlocal Hide_Unit = true --export\nlocal Refresh_Rate = 1 --export\nMaster_Unit = true --export: The board with control screen. Set to false on all other connected boards\nSendOnlyRGB = true -- Sends RGB Values with setScriptInput to all screens, fetch with getInput()\n--BEWARE: SendOnlyRGB = false will overwrite all your screens !!!!\n--------------------------------------------------------------\nlocal version = 1.416\nscreens, lights = {}, {}\n\nfor slot,element in pairs(unit)do -- checking elements in slots\n    if type(element)==\"table\"and type(element.export)==\"table\"then\n        if element.getClass then\n            if element.getClass()==\"ScreenUnit\" or element.getClass()==\"ScreenSignUnit\" then\n                screens[#screens+1]=element\n                screens[#screens].slot=slot\n                element.activate()\n            elseif element.getClass()==\"LightUnit\"then \n                lights[#lights+1]=element\n                element.activate()\n            elseif element.getClass()==\"DataBankUnit\" then\n                Databank = element\n            end \n        end \n    end \nend\n\nif not Databank then\n    system.print(\"ERROR: no databank found\")\n    unit.exit()\nelse\n--    Databank.setStringValue(unit.getLocalId(),unit.getLocalId()..\",\"..#lights..\",\"..#screens)\n    if not Databank.hasKey(\"RGB\") then \n        ScreenVar = \"local BackgroundColor = {r=0,g=0,b=0,h=1}\"\n        Databank.setStringValue(\"RGB\",json.encode({r=0,g=0,b=0,h=1}))\n    else\n        local DB = (json.decode(Databank.getStringValue('RGB')))\n        ScreenVar = [[local BackgroundColor = {r=]].. DB.r ..[[,g=]].. DB.g ..[[,b=]].. DB.b ..[[,h=]].. DB.h ..[[}]]\n    end\nend\n\nif Master_Unit then\n    table.sort(screens, function(a,b) return a.slot < b.slot end) -- sorting screens table by slot\n    ScreenVar = ScreenVar .. [[\n    local Title = \"]] .. Title ..[[\"\n    local Version = ]] .. version ..[[   \n    local BoardList = {}\n    ]] \n    screens[1].setRenderScript(ScreenVar .. ControlScreenContent) -- setting content of control screen\nend\n for i=2, #screens do screens[i].activate() end\n for key, light in pairs(lights) do light.activate() end\nunit.setTimer(\"upd\",Refresh_Rate)\nif Hide_Unit then unit.hideWidget() end\n\n\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},{"code":"if Master_Unit then\n    local ScreenRawOutput = screens[1].getScriptOutput() -- checking action from control screen\n    --system.print(ScreenRawOutput)\n    local ScreenOutput = json.decode(ScreenRawOutput)\n    if ScreenOutput then\n        if ScreenOutput then\n            if SendOnlyRGB == true then\n            for \n                i=2, #screens do screens[i].setScriptInput(json.encode(ScreenOutput))\n                --i=2, #screens do screens[i].setScriptInput(string.format(\"%s\",\"%s\",\"%s\",\"%s\", ScreenOutput.r,ScreenOutput.g,ScreenOutput.b,ScreenOutput.h))\n                system.print(ScreenOutput.r)\n                end\n            else\n            for i=2, #screens do screens[i].setRenderScript(\"local color = {r=\"..ScreenOutput.r..\",g=\".. ScreenOutput.g..\",b=\".. ScreenOutput.b..\",h=\".. ScreenOutput.h..\"}\"..ScreensContent) end\n            end\n            for key, light in pairs(lights) do light.setColor(ScreenOutput.r*ScreenOutput.h,ScreenOutput.g*ScreenOutput.h,ScreenOutput.b*ScreenOutput.h) end\n            screens[1].clearScriptOutput()\n        end\n        if Databank then Databank.setStringValue(\"RGB\",ScreenRawOutput) end\n    end\n\n    if not FirstRun then\n        screens[1].setRenderScript(ScreenVar .. ControlScreenContent) -- setting content of control screen\n        FirstRun = true\n    end\nend\n    \n--else -- if not master_unit\n    if Databank then\n        local ScreenOutput = json.decode(Databank.getStringValue('RGB'))\n        if ScreenOutput then\n        if Master_Unit then j = 2 else j = 1 end\n            if SendOnlyRGB == true then\n            for i=j, #screens do screens[i].setScriptInput(json.encode(ScreenOutput)) end\n            else\n            for i=j, #screens do screens[i].setRenderScript(\"local color = {r=\"..ScreenOutput.r..\",g=\".. ScreenOutput.g..\",b=\".. ScreenOutput.b..\",h=\".. ScreenOutput.h..\"}\"..ScreensContent) end\n            end\n            for key, light in pairs(lights) do light.setColor(ScreenOutput.r*ScreenOutput.h,ScreenOutput.g*ScreenOutput.h,ScreenOutput.b*ScreenOutput.h) end\n        end\n    end\n--end\n\n","filter":{"args":[{"value":"upd"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"1"},{"code":"local DB = (json.decode(Databank.getStringValue('RGB')))\nscreencontent = [[\n--------[ setup layers ]--------\nrx, ry = getResolution()\n\nlocal back = createLayer()\nlocal l2 = createLayer()\nLframe = createLayer() \nLtext = createLayer()\nimage = createLayer()\ninactive_layer = createLayer()\n\n--------[ Setup texts ]--------\n\nText1 = \"DU-LightControl v 1.4.16\"\n\n--------[ setup colours ]--------\ncolor = {r=1,g=1,b=1}\ncolor1 = {r=]]..DB.r*DB.h..[[,g=]]..DB.g*DB.h..[[,b=]]..DB.b*DB.h..[[}  --main Colour set by boards\ncolor2 = {r=0.8,g=0.8,b=0.8}     --T1 Color\ncolor4 = {r=1,g=1,b=1}           --Box Color\n--------[ Background and Font and Logo settings ]--------\n\nlocal enable_background_image = true\nlocal background_image = loadImage(\"assets.prod.novaquark.com/102348/718b6805-93cb-4310-b271-0b20907b05c0.png\")\nsetBackgroundColor (color1.r/6,color1.g/6,color1.b/6)\n\nsetNextFillColor(back, color1.r,color1.g,color1.b, 0.05) --Background Image colour and Transparency\naddImage(back,background_image,0,0,rx,ry)\n\nlocal font_size_xxl = 60\nlocal font_xxl = loadFont('Oxanium-Bold', font_size_xxl)\n    \nlocal font_size_big = 60\nlocal font_big = loadFont('Play-Bold', font_size_big)\n\nlocal font_size_small = 50\nlocal font_small = loadFont('Play', font_size_small)\n\nlocal font_size_desciption = 23\nlocal font_desciption = loadFont('Play', font_size_desciption)    \n    \nsetNextFillColor(Ltext,color1.r,color1.g,color1.b,1)\nsetNextStrokeColor(Ltext,color4.r,color4.g,color4.b,1)\nsetNextStrokeWidth(Ltext,1)\nsetNextTextAlign(Ltext,AlignH_Center,AlignV_Middle)\naddText(Ltext,font_xxl,Text1,rx/2,ry/2-230)\n\n\n    message = \"START THE PROGRAMMING BOARD TO USE\"\n    local wfont = loadFont('Play-Bold', 40)\n    local sx, sy = getTextBounds(wfont, message)\n    setNextFillColor(inactive_layer,color1.r/5,color1.g/5,color1.b/5, 0.8)\n    addBox(inactive_layer,0,0,rx,ry)\n    setNextShadow(inactive_layer, 64, color1.r, color1.g, color1.b, 0.4)\n    setNextFillColor(inactive_layer,color1.r,color1.g,color1.b, 0.8)\n    setNextStrokeColor(inactive_layer,color.r, color.g, color.b, 1)\n    setNextStrokeWidth(inactive_layer,2)\n    addBoxRounded(inactive_layer,(rx-sx-16)/2, (ry-sy-16)/2, sx+16, sy+16, 8)\n    setNextTextAlign(inactive_layer, AlignH_Center, AlignV_Middle)\n    addText(inactive_layer,wfont,message,rx/2,ry/2)\n\n]]\nif Master_Unit then\nscreens[1].setRenderScript(screencontent)\n    end","filter":{"args":[],"signature":"onStop()","slotKey":"-1"},"key":"2"},{"code":"ControlScreenContent = [[\n\n\nlocal json = require(\"dkjson\")\nlocal small = loadFont('Oxanium', 14)\nlocal font = loadFont('Oxanium-Bold', 24)\nlocal rx, ry = getResolution()\nlocal infoFont = loadFont('Oxanium', 12)\nlocal medium = loadFont('Oxanium-Bold', 16)\nlocal big = loadFont('Oxanium-Bold', 46)\nlocal back = createLayer()\nlocal layer = createLayer()\nlocal IconSize = 32\n\nlocal enable_background_image = true\nlocal background_image = loadImage(\"assets.prod.novaquark.com/102348/718b6805-93cb-4310-b271-0b20907b05c0.png\")\n\nsetNextTextAlign( layer, AlignH_Center, AlignV_Middle)\naddText( layer, big, Title, rx*0.28, ry*0.054)\n\nsetNextTextAlign( layer, AlignH_Center, AlignV_Middle)\naddText( layer, medium, \"Screens & Lights Control v\"..Version, rx*0.28, ry*0.98)\n\n----------------------------------------------------------\n------------------ FUNCTIONS -----------------------------\n----------------------------------------------------------\n\n\nfunction Split(s, delimiter)\n    result = {};\n    for match in (s..delimiter):gmatch(\"(.-)\"..delimiter) do\n        table.insert(result, match);\n    end\n    return result;\nend\n\n\n-- Include event library\nlocal event = require('utils/event')\n--local json = require('dkjson')\n\n--# Button class definition called only at the first frame\nif not Button then\n\n    -- getEllipsis( font, text, maxWidth)\n    -- Return a shorten text string by with with ... at the end\n    function getEllipsis(font, text, maxWidth)\n        local width = getTextBounds(font, '...')\n\n        for i = 1, #text do\n            local line = getTextBounds(font, text:sub(1,i)) + width\n            if line > maxWidth then\n                return text:sub(1,i-1)..'...'\n            end\n        end\n        return text\n    end\n\n\n    Button = {}\n    Button.__index = Button\n    -- Button object constructor\n    -- .x : X component of the position\n    -- .y : Y component of the position\n    -- .width : Width of the button\n    -- .height : Height of the button\n    -- .caption : Associated text caption\n    -- .onPressed = event:new() : Event triggered when the button is pressed\n    -- .onDown = event:new() : Event triggered when the button is hold down\n    -- .onReleased = event:new() : Event triggered when the button is released\n    -- .onHover = event:new() : Event triggered when the button is hovered\n    -- .onLeave = event:new() : Event triggered when the button is leave\n    function Button:new(x, y, width, height, caption)\n        local self = {\n            x = x or 0,\n            y = y or 0,\n            w = width or 100,\n            h = height or 20,\n            caption = caption or \"\",\n            onPressed = event:new(),\n            onDown = event:new(),\n            onReleased = event:new(),\n            onEnter = event:new(),\n            onLeave = event:new(),\n            clicked = false,\n            hover = false\n        }\n\n        --Handle button events\n        function self:compute(mx,my)\n            local x, y, w, h = self.x, self.y, self.w, self.h\n\n            if mx>x and mx<x+w and my>y and my<y+h then\n                if getCursorPressed() then\n                    self.onPressed:emit(self,mx,my)\n                    self.clicked = true\n                elseif getCursorReleased() then\n                    self.onReleased:emit(self,mx,my)\n                    self.clicked = false\n                elseif getCursorDown() then\n                    self.onDown:emit(self,mx,my)\n                    self.clicked = true\n                end\n\n                if not self.hover then\n                    self.onEnter:emit(self,mx,my)\n                    self.hover = true\n\n                end\n            elseif self.hover then\n                self.onLeave:emit(self,mx,my)\n                self.hover = false\n            end\n        end\n\n        -- Draws the button on the screen using the given layer\n        function self:draw(layer, font)\n            -- Localize object data\n            local x, y, w, h = self.x, self.y, self.w, self.h\n            local min, max = self.min, self.max\n\n            --# Draw the button\n            -- Define box default strokes style\n            setDefaultStrokeColor(layer, Shape_BoxRounded, 1, 1, 1, 1)\n            setDefaultStrokeWidth(layer, Shape_BoxRounded, 0.1)\n\n            -- If the button is clicked change the background\n            if self.clicked then\n                setNextFillColor(layer, 0.1, 0.1, 0.1, 1)\n            elseif self.hover then\n                setNextFillColor(layer, 0.3, 0.3, 0.3, 1)\n            else\n                setNextFillColor(layer, 0.1, 0.1, 0.1, 1)\n            end\n            addBoxRounded(layer, x, y, w, h, 4)\n\n            -- Draw caption and value display          \n            local caption = getEllipsis(font, self.caption, w-12)\n            local font = font or nil\n\n            setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n            addText( layer, font, caption, x+0.5*w, y+0.5*h)\n        end\n\n\n        return setmetatable(self, Button)\n    end\n\nend\n\n\nlocal mx, my = getCursor()\n\n--# Slider class definition called only at the first frame\nif not Slider then\n\n\n    Slider = {}\n    Slider.__index = Slider\n    -- Slider object constructor\n    -- .x : X component of the position\n    -- .y : Y component of the position\n    -- .width : Width of the slider\n    -- .length : Lenght of the slider\n    -- .min : Minimum value\n    -- .max : Maximum value\n    -- .label : Associated text label\n    function Slider:new(x, y, width, length, min, max, value, label)\n        local self = {\n            x = x or 0,\n            y = y or 0,\n            l = length or 100,\n            w = width or 20,\n            min = min or 0,\n            max = max or 5,\n            ratio = 0,\n            label = label or \"\",\n            drag = false,\n            color = {1,1,1}\n        }\n        self.ratio = math.max(0, math.min(1, (value or self.min)/(self.max-self.min)))\n\n\n\n        -- Set the value of the slider\n        function self:setValue(val)\n            if type(val) == 'number' then\n                self.value = math.max(self.min, math.min(self.max, val))\n            end\n        end\n\n        -- Get the value of the slider\n        function self:getValue(val)\n            return self.ratio*(self.max - self.min) + self.min\n        end\n\n        -- Draws the slider on the screen using the given layer\n        function self:draw(layer)\n\n\n            -- Localize object data\n            local x, y, w, l = self.x, self.y, self.w, self.l\n            local min, max, ratio = self.min, self.max\n\n\n            -- Get cursor data (position and button state)\n            local mx, my = getCursor()\n            local pressed = getCursorPressed()\n            local released = getCursorReleased()\n\n            -- Determine if the cursor is on the bar and detect if the mouse is down\n            if (mx >= x and mx <= x+w) and (my >= y and my <= y+l) then\n\n                if pressed then self.drag = true end\n            end\n            \n             if mx < 0 and self.drag == true then \n                self.drag = false\n                released = true\n                \n            end\n\n            -- Set the ratio based on the cursor position\n            if self.drag then\n                self.ratio = math.max(0, math.min(1, 1 - (my-y)/l))\n                if released then\n                    self.drag = false\n                end\n            end\n\n            -- Compute the slider ratio\n            local ratio = self.ratio\n            --local h = ratio*(max-min)\n            local color = self.color\n           -- if h > 1 then \n              --  setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n              --  addText( layer, font, \"HDR\", x+0.5*w, y+l+50) \n           -- end\n\n            --# Draw the slider\n            -- Define box default strokes style\n            setDefaultStrokeColor(layer, Shape_BoxRounded, 1, 1, 1, 1)\n            setDefaultStrokeWidth(layer, Shape_BoxRounded, 0.1)\n\n            -- Draw the back box\n            setNextFillColor(layer, 0.1, 0.1, 0.1, 1)\n            addBoxRounded(layer, x, y, w, l, 0)\n\n            -- Draw the fill box\n            setNextFillColor(layer, color[1], color[2], color[3], 1)\n            addBoxRounded(layer, x, y+(1-ratio)*l, w, l*ratio, 0)\n\n            -- Draw the handle\n            setNextFillColor(layer, 0.5, 0.5, 0.5, 1)\n            addBoxRounded(layer, x-3, y+(1-ratio)*l -3, w+6, 6, 0)\n\n\n            -- Draw label and value display\n            local label = self.label\n            setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n            addText( layer, font, label, x+0.5*w, y-14)\n\n            local display = string.format('%.2f', ratio*(max - min) + min)\n            setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n            addText( layer, font, display, x+0.5*w, y+l+18)\n        end\n\n\n        return setmetatable(self, Slider)\n    end\n\nend\n\n--------------------------------------------------------------\n------------------ INIT -----------------------------\n--------------------------------------------------------------\n\n--# Initialization called only at the first frame\nif not _init then\n    local r, g, b, h = BackgroundColor.r, BackgroundColor.g, BackgroundColor.b, BackgroundColor.h\n\n    -- Create three sliders and set their color\n    sliderRed = Slider:new(rx*0.6, ry*0.05, 70, ry*0.9, 0, 1, r, \"Red\")\n    sliderRed.color = { 1, 0, 0}\n\n    sliderGreen = Slider:new(rx*0.7, ry*0.05, 70, ry*0.9, 0, 1, g, \"Green\")\n    sliderGreen.color = { 0, 1, 0}\n\n    sliderBlue = Slider:new(rx*0.8, ry*0.05, 70, ry*0.9, 0, 1, b, \"Blue\")\n    sliderBlue.color = { 0, 0, 1}\n\n    sliderHDR = Slider:new(rx*0.9, ry*0.05, 70, ry*0.9, 0, 5, h, \"HDR\")\n    sliderHDR.color = { 1, 1, 1}\n\n    -- Draw the SET buttons\n    _button_setLights = Button:new(rx*0.05+rx*0.225-100, 0.54*ry, 200, 58, \"Set Color\")\n\n    --Add the action on the actions event.\n    --event:addAction( call, enabled, limit)\n\n\n    _button_setLights.onReleased:addAction( function(self,x,y)\n            setOutput(json.encode(\n                    {\n                            [\"r\"] = R,\n                            [\"g\"] = G,\n                            [\"b\"] = B,\n                            [\"h\"] = H,\n})\n            )\n        end, true)\n\n\n    _init = true\nend\n\n\n--------------------------------------------------------------\n--------------------------------------------------------------\n\n-- Draw buttons\n_button_setLights:compute(mx,my)\n_button_setLights:draw( layer, medium)\n\n\n-- Draw a box behind the sliders\n--setNextFillColor( layer, 0.05, 0.05, 0.05, 1)\n--addBoxRounded( layer, rx*0.55, ry*0.11, rx*0.415, ry*0.85, 16)\n\n\n-- Draw sliders\nsliderRed:draw( layer)\nsliderGreen:draw( layer)\nsliderBlue:draw( layer)\nsliderHDR:draw( layer)\n\n\nH = sliderHDR:getValue()\nR = sliderRed:getValue()\nG = sliderGreen:getValue()\nB = sliderBlue:getValue()\n\n\n--# Rendering\n-- Set the background color based on sliders value\n-- Box background\n\nsetBackgroundColor (R*H/6,G*H/6,B*H/6)\nif enable_background_image == true then\n    setNextFillColor(back, R*H,  G*H, B*H, 0.05) --Background Image colour and Transparency\n    addImage(back, background_image, 0, 0, rx, ry)\nend\n\nsetNextFillColor( layer, R*H,  G*H, B*H, 1)\naddBoxRounded( layer, rx*0.05, ry*0.66, rx*0.45, ry*0.3, 16)\n\n-- Request a run at each frame\nrequestAnimationFrame(1)\n\n]]","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"3"},{"code":"ScreensContent = [[\n\n\nlocal json = require(\"dkjson\")\nlocal layer = createLayer()\nlocal rx,ry=getResolution() \n\nfor i=0, 1, 0.03 do\n    setNextStrokeColor(layer,0, 0, 0,1)\n    addLine(layer,0,ry*i,rx,ry*i)\nend\n\n\n    setBackgroundColor(color.r*color.h, color.g*color.h, color.b*color.h)\n--setOutput(json.encode(color))\n\n]]","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"4"}],"methods":[],"events":[]}
